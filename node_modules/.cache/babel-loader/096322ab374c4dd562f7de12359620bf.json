{"ast":null,"code":"// Original code from : https://gist.github.com/mikelehen/3596a30bd69384624c11\n\n/**\n * Fancy ID generator that creates 20-character string identifiers with the following properties:\n *\n * 1. They're based on timestamp so that they sort *after* any existing ids.\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't collide with other clients' IDs.\n * 3. They sort *lexicographically* (so the timestamp is converted to characters that will sort properly).\n * 4. They're monotonically increasing.  Even if you generate more than one in the same timestamp, the\n *    latter ones will sort after the former ones.  We do this by using the previous random bits\n *    but \"incrementing\" them by 1 (only in the case of a timestamp collision).\n */\n// Modeled after base64 web-safe chars, but ordered by ASCII.\nvar PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'; // Timestamp of last push, used to prevent local collisions if you push twice in one ms.\n\nvar lastPushTime = 0; // We generate 72-bits of randomness which get turned into 12 characters and appended to the\n// timestamp to prevent collisions with other clients.  We store the last characters we\n// generated because in the event of a collision, we'll use those same characters except\n// \"incremented\" by one.\n\nvar lastRandChars = [];\n\nmodule.exports = function pushid() {\n  var now = new Date().getTime();\n  var duplicateTime = now === lastPushTime;\n  lastPushTime = now;\n  var timeStampChars = new Array(8);\n\n  for (var i = 7; i >= 0; i--) {\n    timeStampChars[i] = PUSH_CHARS.charAt(now % 64); // NOTE: Can't use << here because javascript will convert to int and lose the upper bits.\n\n    now = Math.floor(now / 64);\n  }\n\n  if (now !== 0) {\n    throw new Error('We should have converted the entire timestamp.');\n  }\n\n  var id = timeStampChars.join('');\n\n  if (duplicateTime) {\n    // If the timestamp hasn't changed since last push, use the same random number, except incremented by 1.\n    for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n      lastRandChars[i] = 0;\n    }\n\n    lastRandChars[i]++;\n  } else {\n    for (i = 0; i < 12; i++) {\n      lastRandChars[i] = Math.floor(Math.random() * 64);\n    }\n  }\n\n  for (i = 0; i < 12; i++) {\n    id += PUSH_CHARS.charAt(lastRandChars[i]);\n  }\n\n  if (id.length != 20) {\n    throw new Error('Length should be 20.');\n  }\n\n  return id;\n};","map":{"version":3,"sources":["D:/WEBD/Projects(khud se)/IDE(task)/my-app/client/node_modules/pushid/index.js"],"names":["PUSH_CHARS","lastPushTime","lastRandChars","module","exports","pushid","now","Date","getTime","duplicateTime","timeStampChars","Array","i","charAt","Math","floor","Error","id","join","random","length"],"mappings":"AAAA;;AAEA;;;;;;;;;;AAWA;AACA,IAAIA,UAAU,GAAG,kEAAjB,C,CAEA;;AACA,IAAIC,YAAY,GAAG,CAAnB,C,CAEA;AACA;AACA;AACA;;AACA,IAAIC,aAAa,GAAG,EAApB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,MAAT,GAAkB;AACjC,MAAIC,GAAG,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAV;AACA,MAAIC,aAAa,GAAIH,GAAG,KAAKL,YAA7B;AACAA,EAAAA,YAAY,GAAGK,GAAf;AAEA,MAAII,cAAc,GAAG,IAAIC,KAAJ,CAAU,CAAV,CAArB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3BF,IAAAA,cAAc,CAACE,CAAD,CAAd,GAAoBZ,UAAU,CAACa,MAAX,CAAkBP,GAAG,GAAG,EAAxB,CAApB,CAD2B,CAE3B;;AACAA,IAAAA,GAAG,GAAGQ,IAAI,CAACC,KAAL,CAAWT,GAAG,GAAG,EAAjB,CAAN;AACD;;AAED,MAAIA,GAAG,KAAK,CAAZ,EAAe;AACb,UAAM,IAAIU,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAED,MAAIC,EAAE,GAAGP,cAAc,CAACQ,IAAf,CAAoB,EAApB,CAAT;;AAEA,MAAKT,aAAL,EAAqB;AACnB;AACA,SAAKG,CAAC,GAAG,EAAT,EAAaA,CAAC,IAAI,CAAL,IAAUV,aAAa,CAACU,CAAD,CAAb,KAAqB,EAA5C,EAAgDA,CAAC,EAAjD,EAAqD;AACnDV,MAAAA,aAAa,CAACU,CAAD,CAAb,GAAmB,CAAnB;AACD;;AACDV,IAAAA,aAAa,CAACU,CAAD,CAAb;AACD,GAND,MAOK;AACH,SAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,EAAhB,EAAoBA,CAAC,EAArB,EAAyB;AACvBV,MAAAA,aAAa,CAACU,CAAD,CAAb,GAAmBE,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACK,MAAL,KAAgB,EAA3B,CAAnB;AACD;AACF;;AAED,OAAKP,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,EAAhB,EAAoBA,CAAC,EAArB,EAAyB;AACvBK,IAAAA,EAAE,IAAIjB,UAAU,CAACa,MAAX,CAAkBX,aAAa,CAACU,CAAD,CAA/B,CAAN;AACD;;AAED,MAAKK,EAAE,CAACG,MAAH,IAAa,EAAlB,EAAuB;AACrB,UAAM,IAAIJ,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,SAAOC,EAAP;AACD,CAxCD","sourcesContent":["// Original code from : https://gist.github.com/mikelehen/3596a30bd69384624c11\n\n/**\n * Fancy ID generator that creates 20-character string identifiers with the following properties:\n *\n * 1. They're based on timestamp so that they sort *after* any existing ids.\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't collide with other clients' IDs.\n * 3. They sort *lexicographically* (so the timestamp is converted to characters that will sort properly).\n * 4. They're monotonically increasing.  Even if you generate more than one in the same timestamp, the\n *    latter ones will sort after the former ones.  We do this by using the previous random bits\n *    but \"incrementing\" them by 1 (only in the case of a timestamp collision).\n */\n\n// Modeled after base64 web-safe chars, but ordered by ASCII.\nvar PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\n\n// Timestamp of last push, used to prevent local collisions if you push twice in one ms.\nvar lastPushTime = 0;\n\n// We generate 72-bits of randomness which get turned into 12 characters and appended to the\n// timestamp to prevent collisions with other clients.  We store the last characters we\n// generated because in the event of a collision, we'll use those same characters except\n// \"incremented\" by one.\nvar lastRandChars = [];\n\nmodule.exports = function pushid() {\n  var now = new Date().getTime();\n  var duplicateTime = (now === lastPushTime);\n  lastPushTime = now;\n\n  var timeStampChars = new Array(8);\n  for (var i = 7; i >= 0; i--) {\n    timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n    // NOTE: Can't use << here because javascript will convert to int and lose the upper bits.\n    now = Math.floor(now / 64);\n  }\n\n  if (now !== 0) {\n    throw new Error('We should have converted the entire timestamp.');\n  }\n\n  var id = timeStampChars.join('');\n\n  if ( duplicateTime ) {\n    // If the timestamp hasn't changed since last push, use the same random number, except incremented by 1.\n    for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n      lastRandChars[i] = 0;\n    }\n    lastRandChars[i]++;\n  }\n  else {\n    for (i = 0; i < 12; i++) {\n      lastRandChars[i] = Math.floor(Math.random() * 64);\n    }\n  }\n\n  for (i = 0; i < 12; i++) {\n    id += PUSH_CHARS.charAt(lastRandChars[i]);\n  }\n\n  if ( id.length != 20 ) {\n    throw new Error('Length should be 20.');\n  }\n\n  return id;\n};\n"]},"metadata":{},"sourceType":"script"}